{"version":3,"sources":["moonbit:///@builtin/console.mbt","moonbit:///@mario/main/sprite.mbt","moonbit:///@mario/main/draw.mbt","moonbit:///@mario/main/util.mbt","moonbit:///@mario/main/object.mbt","moonbit:///@mario/main/particle.mbt","moonbit:///@mario/main/director.mbt","moonbit:///@mario/main/temp.mbt","moonbit:///@mario/main/viewport.mbt","moonbit:///@mario/main/procedural_generator.mbt","moonbit:///@mario/main/main.mbt"],"sourcesContent":["pub fn println[T : Show](input : T) -> Unit {\n  print_string(input.to_string())\n  print_string(\"\\n\")\n}\n\npub fn print[T : Show](input : T) -> Unit{\n  print_string(input.to_string())\n}\n\npub fn to_string(self : Bool) -> String {\n  if self { \n    \"true\"\n  } else {\n    \"false\"\n  }\n}\n\npub fn to_string(self : Int64) -> String {\n  fn abs(n : Int64) -> Int64 {\n    if n < 0L {\n      0L - n\n    } else {\n      n\n    }\n  }\n  \n  // The min and max value of i64 are -9223372036854775808 and 9223372036854775807,\n  // so max=20 is enough. \n  let max = 20\n  let bytes = Bytes::make(max,0)\n  let mut num = self\n  let mut p = max\n  while true {\n    p = p - 1 \n    let c = 48 + abs(num % 10L).to_int()\n    bytes[p] = c\n    num = num / 10L\n    if num == 0L { break }\n  }\n\n  if self < 0L {\n    p = p - 1\n    bytes[p] = '-'.to_int()\n  }\n\n  bytes.sub_string(p, max - p)\n}\n\npub fn to_string(self : Int) -> String {\n  fn abs(n : Int) -> Int {\n    if n < 0 {\n      0 - n\n    } else {\n      n\n    }\n  }\n \n  // The min and max value of i32 are -2147483648 and 2147483647,\n  // so max=11 is enough.\n  let max = 11\n  let bytes = Bytes::make(max,0)\n  let mut num = self\n  let mut p = max\n  while true {\n    p = p - 1 \n    let c = 48 + abs(num % 10)\n    bytes[p] = c\n    num = num / 10\n    if num == 0 { break }\n  }\n\n  if self < 0 {\n    p = p - 1\n    bytes[p] = '-'.to_int()\n  }\n\n  bytes.sub_string(p, max - p)\n}\n\npub fn to_int(self : Bool) -> Int {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\npub fn to_int64(self : Bool) -> Int64 {\n  if self {\n    1L\n  } else {\n    0L\n  }\n}\n\nfn to_bool(self : Int) -> Bool {\n  if self == 0 {\n    false\n  } else {\n    true\n  }\n}\n\nfn to_bool(self : Int64) -> Bool {\n  if self == 0L {\n    false\n  } else {\n    true\n  }\n}\n\npub fn to_string(self : Double) -> String {\n  double_to_string(self)\n}\n\npub fn op_lt[T: Compare](self_: T, other: T) -> Bool {\n  self_.compare(other).is_neg()\n}\n\npub fn op_gt[T: Compare](self_: T, other: T) -> Bool {\n  self_.compare(other).is_pos()\n}\n\npub fn op_le[T: Compare](self_: T, other: T) -> Bool {\n  self_.compare(other).is_non_pos()\n}\n\npub fn op_ge[T: Compare](self_: T, other: T) -> Bool {\n  self_.compare(other).is_non_neg()\n}\n\npub fn op_notequal[T: Eq](x: T, y: T) -> Bool {\n  not(x == y)\n}\n\n/// A reference to string in host JS.\npub type Js_string\n\n/// Create a JS string from a string in Moonbit by calling intrinsic primitive\npub fn Js_string::new(x: String) -> Js_string {\n  x.to_js_string()\n}\n\n/// Call FFI to log the JS string\npub fn log(self: Js_string) = \"js_string\" \"log\"\n\n/// Call FFI to append two JS strings\npub fn op_add(self: Js_string, other: Js_string) -> Js_string = \"js_string\" \"append\"\n\n\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n/// Create new string of `length`, where each character is `value`\n/// \n/// ```\n/// println(String::make(5,'S')) // Output: \"SSSSS\"\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  if length < 0 { \n    abort(\"invalid length\") \n  } else {\n    unsafe_make_string(length, value)\n  }\n}\n\n/// Convert Char to String\npub fn to_string(self : Char) -> String {\n  let bytes = Bytes::make(4, 0)\n  let len = bytes.set_utf8_char(0, self)\n  bytes.sub_string(0, len)\n}\n","struct SpriteParams {\n  max_frames : Int\n  max_ticks : Int\n  img_src : Image\n  frame_size : (Double, Double)\n  src_offset : (Double, Double)\n  bbox_offset : (Double, Double)\n  bbox_size : (Double, Double)\n  loop : Bool\n}\n\nstruct Sprite {\n  mut params : SpriteParams\n  frame : Ref[Int]\n  ticks : Ref[Int]\n  mut img : Image\n}\n\nfn setup_sprite(loop : Bool, bbox_offset : (Double, Double),\n        bbox_size : (Double, Double), img_src : Image, max_frames : Int,\n        max_ticks : Int, frame_size : (Double, Double),\n        src_offset : (Double, Double)) -> SpriteParams {\n  {\n    img_src,\n    max_frames,\n    max_ticks,\n    frame_size,\n    src_offset,\n    bbox_offset,\n    bbox_size,\n    loop,\n  }\n}\n\nfn setup_sprite_(img_src : Image, max_frames : Int, max_ticks : Int,\n        frame_size : (Double, Double), src_offset : (Double, Double)) ->\n     SpriteParams {\n  {\n    img_src,\n    max_frames,\n    max_ticks,\n    frame_size,\n    src_offset,\n    bbox_offset: (0.0, 0.0),\n    bbox_size: frame_size,\n    loop: true,\n  }\n}\n\nfn make_small_player(player : Player, dir1d : Dir1d) -> SpriteParams {\n  match (player, dir1d) {\n    (Standing, Left) => setup_sprite(\n      true,\n      (3.0, 1.0),\n      (11.0, 15.0),\n      small_,\n      1,\n      0,\n      (16.0, 16.0),\n      (0.0, 0.0),\n    )\n    (Standing, Right) => setup_sprite(\n      true,\n      (1.0, 1.0),\n      (11.0, 15.0),\n      small_,\n      1,\n      0,\n      (16.0, 16.0),\n      (0.0, 32.0),\n    )\n    (Jumping, Left) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (13.0, 15.0),\n      small_,\n      2,\n      10,\n      (16.0, 16.0),\n      (16.0, 16.0),\n    )\n    (Jumping, Right) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (13.0, 15.0),\n      small_,\n      2,\n      10,\n      (16.0, 16.0),\n      (16.0, 48.0),\n    )\n    (Running, Left) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (12.0, 15.0),\n      small_,\n      3,\n      5,\n      (16.0, 16.0),\n      (16.0, 0.0),\n    )\n    (Running, Right) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (12.0, 15.0),\n      small_,\n      3,\n      5,\n      (16.0, 16.0),\n      (16.0, 32.0),\n    )\n    (Crouching, _) => setup_sprite(\n      true,\n      (1.0, 5.0),\n      (14.0, 10.0),\n      small_,\n      1,\n      10,\n      (16.0, 16.0),\n      (0.0, 64.0),\n    )\n  }\n}\n\nfn make_large_player(player : Player, dir1d : Dir1d) -> SpriteParams {\n  match (player, dir1d) {\n    (Standing, Left) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (13.0, 25.0),\n      large_,\n      1,\n      0,\n      (16.0, 27.0),\n      (16.0, 5.0),\n    )\n    (Standing, Right) => setup_sprite(\n      true,\n      (1.0, 1.0),\n      (13.0, 25.0),\n      large_,\n      1,\n      0,\n      (16.0, 26.0),\n      (16.0, 69.0),\n    )\n    (Jumping, Left) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (12.0, 25.0),\n      large_,\n      1,\n      0,\n      (16.0, 26.0),\n      (48.0, 6.0),\n    )\n    (Jumping, Right) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (12.0, 25.0),\n      large_,\n      1,\n      0,\n      (16.0, 26.0),\n      (48.0, 70.0),\n    )\n    (Running, Left) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (13.0, 25.0),\n      large_,\n      4,\n      10,\n      (16.0, 27.0),\n      (0.0, 37.0),\n    )\n    (Running, Right) => setup_sprite(\n      true,\n      (2.0, 1.0),\n      (13.0, 25.0),\n      large_,\n      4,\n      10,\n      (16.0, 27.0),\n      (0.0, 101.0),\n    )\n    (Crouching, _) => setup_sprite(\n      true,\n      (2.0, 10.0),\n      (13.0, 17.0),\n      large_,\n      1,\n      0,\n      (16.0, 27.0),\n      (32.0, 5.0),\n    )\n  }\n}\n\nfn make_enemy(enemy : Enemy, dir1d : Dir1d) -> SpriteParams {\n  match (enemy, dir1d) {\n    (Goomba, _) => setup_sprite(\n      true,\n      (1.0, 1.0),\n      (14.0, 14.0),\n      enemy_,\n      2,\n      10,\n      (16.0, 16.0),\n      (0.0, 128.0),\n    )\n    (GKoopa, Left) => setup_sprite(\n      true,\n      (4.0, 10.0),\n      (11.0, 16.0),\n      enemy_,\n      2,\n      10,\n      (16.0, 27.0),\n      (0.0, 69.0),\n    )\n    (RKoopa, Left) => setup_sprite(\n      true,\n      (4.0, 10.0),\n      (11.0, 16.0),\n      enemy_,\n      2,\n      10,\n      (16.0, 27.0),\n      (0.0, 5.0),\n    )\n    (GKoopa, Right) => setup_sprite(\n      true,\n      (1.0, 10.0),\n      (11.0, 16.0),\n      enemy_,\n      2,\n      10,\n      (16.0, 27.0),\n      (32.0, 69.0),\n    )\n    (RKoopa, Right) => setup_sprite(\n      true,\n      (1.0, 10.0),\n      (11.0, 16.0),\n      enemy_,\n      2,\n      10,\n      (16.0, 27.0),\n      (32.0, 5.0),\n    )\n    (GKoopaShell, _) => setup_sprite(\n      true,\n      (2.0, 2.0),\n      (12.0, 13.0),\n      enemy_,\n      4,\n      10,\n      (16.0, 16.0),\n      (0.0, 96.0),\n    )\n    (RKoopaShell, _) => setup_sprite(\n      true,\n      (2.0, 2.0),\n      (12.0, 13.0),\n      enemy_,\n      4,\n      10,\n      (16.0, 16.0),\n      (0.0, 32.0),\n    )\n  }\n}\n\nfn make_item(item : Item) -> SpriteParams {\n  match item {\n    Coin => setup_sprite(\n      true,\n      (3.0, 0.0),\n      (12.0, 16.0),\n      items_,\n      3,\n      15,\n      (16.0, 16.0),\n      (0.0, 80.0),\n    )\n    Mushroom => setup_sprite(\n      true,\n      (2.0, 0.0),\n      (12.0, 16.0),\n      items_,\n      1,\n      0,\n      (16.0, 16.0),\n      (0.0, 0.0),\n    )\n  }\n}\n\nfn make_block(block : Block) -> SpriteParams {\n  match block {\n    Brick => setup_sprite_(block_, 5, 10, (16.0, 16.0), (0.0, 0.0))\n    QBlock(_) => setup_sprite_(block_, 4, 15, (16.0, 16.0), (0.0, 16.0))\n    QBlockUsed => setup_sprite_(block_, 1, 0, (16.0, 16.0), (0.0, 32.0))\n    UnBBlock => setup_sprite_(block_, 1, 0, (16.0, 16.0), (0.0, 48.0))\n    Cloud => setup_sprite_(block_, 1, 0, (16.0, 16.0), (0.0, 64.0))\n    Panel => setup_sprite_(panel_, 3, 15, (26.0, 26.0), (0.0, 0.0))\n    Ground => setup_sprite_(ground, 1, 0, (16.0, 16.0), (0.0, 32.0))\n  }\n}\n\nfn make_particle(particle : Part) -> SpriteParams {\n  match particle {\n    GoombaSquish => setup_sprite_(enemy_, 1, 0, (16.0, 16.0), (0.0, 144.0))\n    BrickChunkL => setup_sprite_(chunk_, 1, 0, (8.0, 8.0), (0.0, 0.0))\n    BrickChunkR => setup_sprite_(chunk_, 1, 0, (8.0, 8.0), (8.0, 0.0))\n    Score100 => setup_sprite_(score_, 1, 0, (12.0, 8.0), (0.0, 0.0))\n    Score200 => setup_sprite_(score_, 1, 0, (12.0, 9.0), (0.0, 9.0))\n    Score400 => setup_sprite_(score_, 1, 0, (12.0, 9.0), (0.0, 18.0))\n    Score800 => setup_sprite_(score_, 1, 0, (12.0, 9.0), (0.0, 27.0))\n    Score1000 => setup_sprite_(score_, 1, 0, (14.0, 9.0), (13.0, 0.0))\n    Score2000 => setup_sprite_(score_, 1, 0, (14.0, 9.0), (13.0, 9.0))\n    Score4000 => setup_sprite_(score_, 1, 0, (14.0, 9.0), (13.0, 18.0))\n    Score8000 => setup_sprite_(score_, 1, 0, (14.0, 9.0), (13.0, 27.0))\n  }\n}\n\nfn make_player(player_size : PlayerSize, player : Player, dir1d : Dir1d) ->\n     SpriteParams {\n  match player_size {\n    Large => make_large_player(player, dir1d)\n    Small => make_small_player(player, dir1d)\n  }\n}\n\nfn SpriteParams::make(spawn : Spawn, dir1d : Dir1d) -> SpriteParams {\n  match spawn {\n    Player(x, y) => make_player(x, y, dir1d)\n    Enemy(x) => make_enemy(x, dir1d)\n    Item(x) => make_item(x)\n    Block(x) => make_block(x)\n  }\n}\n\nfn Sprite::make_(params : SpriteParams) -> Sprite {\n  { params, frame: Ref::make(0), ticks: Ref::make(0), img: params.img_src }\n}\n\nfn Sprite::make(spawn : Spawn, dir1d : Dir1d) -> Sprite {\n  Sprite::make_(SpriteParams::make(spawn, dir1d))\n}\n\nfn make_bgd() -> Sprite {\n  let params = setup_sprite_(backg_, 1, 0, (512.0, 256.0), (0.0, 0.0))\n  Sprite::make_(params)\n}\n\nfn transform_enemy(enemy_typ : Enemy, spr : Sprite, dir : Dir1d) {\n  let params = make_enemy(enemy_typ, dir)\n  let img = params.img_src\n  spr.params = params\n  spr.img = img\n}\n\nfn update_animation(spr : Sprite) {\n  let curr_ticks = spr.ticks.value\n  if curr_ticks >= spr.params.max_ticks {\n    spr.ticks.value = 0\n    if spr.params.loop {\n      spr.frame.value = (spr.frame.value + 1) % spr.params.max_frames\n    }\n  } else {\n    spr.ticks.value = curr_ticks + 1\n  }\n}\n","type Image\n\nfn get_backg() -> Image = \"canvas\" \"get_backg\"\n\nfn get_block() -> Image = \"canvas\" \"get_block\"\n\nfn get_items() -> Image = \"canvas\" \"get_items\"\n\nfn get_enemy() -> Image = \"canvas\" \"get_enemy\"\n\nfn get_small() -> Image = \"canvas\" \"get_small\"\n\nfn get_large() -> Image = \"canvas\" \"get_large\"\n\nfn get_panel() -> Image = \"canvas\" \"get_panel\"\n\nfn get_round() -> Image = \"canvas\" \"get_round\"\n\nfn get_chunk() -> Image = \"canvas\" \"get_chunk\"\n\nfn get_score() -> Image = \"canvas\" \"get_score\"\n\nlet backg_ : Image = get_backg()\n\nlet block_ : Image = get_block()\n\nlet items_ : Image = get_items()\n\nlet enemy_ : Image = get_enemy()\n\nlet small_ : Image = get_small()\n\nlet large_ : Image = get_large()\n\nlet panel_ : Image = get_panel()\n\nlet ground : Image = get_round()\n\nlet chunk_ : Image = get_chunk()\n\nlet score_ : Image = get_score()\n\nfn game_win() = \"canvas\" \"game_win\"\n\nfn game_lose() = \"canvas\" \"game_lose\"\n\nfn random(l : Int, r : Int) -> Int = \"canvas\" \"random\"\n\nfn render_(img : Image, sx : Double, sy : Double, sw : Double, sh : Double,\n        dx : Double, dy : Double, dw : Double, dh : Double) = \"canvas\" \"render\"\n\nfn render_box_(a : Double, b : Double, c : Double, d : Double) = \"canvas\" \"render_box\"\n\nfn render_box(sprite : Sprite, posx : Double, posy : Double) {\n  let (bbox, bboy) = sprite.params.bbox_offset\n  let (bbsx, bbsy) = sprite.params.bbox_size\n  render_box_(posx + bbox, posy + bboy, bbsx, bbsy)\n}\n\nfn render(sprite : Sprite, posx : Double, posy : Double) {\n  let (sx, sy) = sprite.params.src_offset\n  let (sw, sh) = sprite.params.frame_size\n  let (dx, dy) = (posx, posy)\n  let (dw, dh) = sprite.params.frame_size\n  let sx = sx + sprite.frame.value.to_double() * sw\n  render_(sprite.img, sx, sy, sw, sh, dx, dy, dw, dh)\n}\n\n// (*Draws two background images, which needs to be done because of the\n// *constantly changing viewport, which is always at most going to be\n// *between two background images.*)\nfn draw_bgd(bgd : Sprite, off_x : Double) {\n  render(bgd, -off_x, 0.0)\n  render(bgd, bgd.params.frame_size.0 - off_x, 0.0)\n}\n\nfn clear_canvas() = \"canvas\" \"clear\"\n\nfn hud(score : Int, coins : Int) = \"canvas\" \"draw_hud\"\n\nfn fps(fps_val : Int) = \"canvas\" \"draw_fps\"\n","fn min[T : Compare](a : T, b : T) -> T {\n  if a < b {\n    a\n  } else {\n    b\n  }\n}\n\nfn max[T : Compare](a : T, b : T) -> T {\n  if a < b {\n    b\n  } else {\n    a\n  }\n}\n\nfn abs(this : Double) -> Double {\n  if this < 0.0 {\n    -this\n  } else {\n    this\n  }\n}\n\nstruct Ref[T] {\n  mut value : T\n}\n\nfn Ref::make[T](value : T) -> Ref[T] {\n  { value, }\n}\n\nfn filter[T](this : List[T], f : (T) -> Bool) -> List[T] {\n  match this {\n    Nil => Nil\n    Cons(x, xs) => if f(x) {\n      Cons(x, filter(xs, f))\n    } else {\n      filter(xs, f)\n    }\n  }\n}\n\nfn map[T, U](this : List[T], f : (T) -> U) -> List[U] {\n  match this {\n    Nil => Nil\n    Cons(x, xs) => Cons(f(x), map(xs, f))\n  }\n}\n\nfn tolist[T](this : Array[T]) -> List[T] {\n  let len = this.length()\n  fn aux(i) {\n    if i < len {\n      List::Cons(this[i], aux(i + 1))\n    } else {\n      List::Nil\n    }\n  }\n\n  aux(0)\n}\n\nfn concat[X](this : List[X], ys : List[X]) -> List[X] {\n  match this {\n    Nil => ys\n    Cons(x, rest) => Cons(x, concat(rest, ys))\n  }\n}\n\nfn first[X](this : List[X], predicate : (X) -> Bool) -> Option[X] {\n  match this {\n    Nil => None\n    Cons(x, xs) => if predicate(x) {\n      Some(x)\n    } else {\n      first(xs, predicate)\n    }\n  }\n}\n\nfn last[X](this : List[X], predicate : (X) -> Bool) -> Option[X] {\n  match this {\n    Nil => None\n    Cons(x, xs) => match last(xs, predicate) {\n      Some(_) as ans => ans\n      None => if predicate(x) {\n        Some(x)\n      } else {\n        None\n      }\n    }\n  }\n}\n\nfn at[X](this : List[X], index : Int) -> X {\n  if index < 0 {\n    abort(\"invalid index\")\n  }\n  fn at_helper(l : List[X], index : Int) -> X {\n    match l {\n      Nil => abort(\"invalid index\")\n      Cons(x, xs) => if index == 0 {\n        x\n      } else {\n        at_helper(xs, index - 1)\n      }\n    }\n  }\n\n  at_helper(this, index)\n}\n","let friction : Double = 0.9\n\nlet gravity : Double = 0.2\n\nlet max_y_vel : Double = 4.5\n\nlet player_speed : Double = 2.8\n\nlet player_jump : Double = 5.7\n\nlet player_max_jump : Double = -6.0\n\nlet dampen_jump : Double = 4.0\n\nlet invuln : Int = 60\n\nstruct AABB {\n  center : XY\n  half : XY\n}\n\nstruct ObjectParams {\n  has_gravity : Bool\n  speed : Double\n}\n\nlet id_counter : Ref[Int] = Ref::make(0)\n\nstruct Object {\n  params : ObjectParams\n  pos : XY\n  vel : XY\n  id : Int\n  mut jumping : Bool\n  mut grounded : Bool\n  mut dir : Dir1d\n  mut invuln : Int\n  mut kill : Bool\n  mut health : Int\n  mut crouch : Bool\n  mut score : Int\n}\n\nenum Collidable {\n  Player(PlayerSize, Sprite, Object)\n  Enemy(Enemy, Sprite, Object)\n  Item(Item, Sprite, Object)\n  Block(Block, Sprite, Object)\n}\n\nfn setup_objp2(has_gravity : Bool, speed : Double) -> ObjectParams {\n  { has_gravity, speed }\n}\n\nfn setup_objp() -> ObjectParams {\n  setup_objp2(true, 1.0)\n}\n\nfn set_vel_to_speed(self : Object) {\n  let speed = self.params.speed\n  match self.dir {\n    Left => {\n      self.vel.x = -speed\n    }\n    Right => {\n      self.vel.x = speed\n    }\n  }\n}\n\nfn makeplayer() -> ObjectParams {\n  setup_objp2(true, player_speed)\n}\n\nfn makeitem(item : Item) -> ObjectParams {\n  match item {\n    Mushroom => setup_objp()\n    Coin => setup_objp2(false, 1.0)\n  }\n}\n\nfn makeenemy(enemy : Enemy) -> ObjectParams {\n  match enemy {\n    Goomba => setup_objp()\n    GKoopa => setup_objp()\n    RKoopa => setup_objp()\n    GKoopaShell => setup_objp2(true, 3.0)\n    RKoopaShell => setup_objp2(true, 3.0)\n  }\n}\n\nfn makeblock() -> ObjectParams {\n  setup_objp2(false, 1.0)\n}\n\nfn make_type(spawn : Spawn) -> ObjectParams {\n  match spawn {\n    Player(_) => makeplayer()\n    Enemy(t) => makeenemy(t)\n    Item(t) => makeitem(t)\n    Block(_) => makeblock()\n  }\n}\n\nfn new_id() -> Int {\n  id_counter.value = id_counter.value + 1\n  id_counter.value\n}\n\nfn makeobj(id : Int, dir : Dir1d, spawn : Spawn, posx : Double, posy : Double) ->\n     (Sprite, Object) {\n  let spr = Sprite::make(spawn, dir)\n  let params = make_type(spawn)\n  let obj : Object = {\n    params,\n    pos: { x: posx, y: posy },\n    vel: { x: 0.0, y: 0.0 },\n    id,\n    jumping: false,\n    grounded: false,\n    dir,\n    invuln: 0,\n    kill: false,\n    health: 1,\n    crouch: false,\n    score: 0,\n  }\n  (spr, obj)\n}\n\nfn spawn(spawnable : Spawn, posx : Double, posy : Double) -> Collidable {\n  let (spr, obj) = makeobj(new_id(), Left, spawnable, posx, posy)\n  match spawnable {\n    Player(typ, _) => Player(typ, spr, obj)\n    Enemy(t) => {\n      set_vel_to_speed(obj)\n      Enemy(t, spr, obj)\n    }\n    Item(t) => Item(t, spr, obj)\n    Block(t) => Block(t, spr, obj)\n  }\n}\n\nfn get_sprite(self : Collidable) -> Sprite {\n  match self {\n    Player(_, s, _) | Enemy(_, s, _) | Item(_, s, _) | Block(_, s, _) => s\n  }\n}\n\nfn get_obj(self : Collidable) -> Object {\n  match self {\n    Player(_, _, o) | Enemy(_, _, o) | Item(_, _, o) | Block(_, _, o) => o\n  }\n}\n\nfn is_player(self : Collidable) -> Bool {\n  match self {\n    Player(_) => true\n    _ => false\n  }\n}\n\nfn is_enemy(self : Collidable) -> Bool {\n  match self {\n    Enemy(_) => true\n    _ => false\n  }\n}\n\nfn op_equal(self : Collidable, optb : Collidable) -> Bool {\n  return self.get_obj().id == optb.get_obj().id\n}\n\nfn update_player_keys(player : Object, controls : Control) {\n  let lr_acc = player.vel.x * 0.2\n  match controls {\n    Left => if player.crouch.not() {\n      if player.vel.x > -player.params.speed {\n        player.vel.x = player.vel.x - (0.4 - lr_acc)\n      }\n      player.dir = Left\n    }\n    Right => if player.crouch.not() {\n      if player.vel.x < player.params.speed {\n        player.vel.x = player.vel.x + (0.4 + lr_acc)\n      }\n      player.dir = Right\n    }\n    Up => if player.jumping.not() && player.grounded {\n      player.jumping = true\n      player.grounded = false\n      player.vel.y = max(\n        player.vel.y - (player_jump + abs(player.vel.x * 0.25)),\n        player_max_jump,\n      )\n    }\n    Down => if player.jumping.not() && player.grounded {\n      player.crouch = true\n    }\n  }\n}\n\nfn normalize_pos(pos : XY, p1 : SpriteParams, p2 : SpriteParams) {\n  let (box1, boy1) = p1.bbox_offset\n  let (box2, boy2) = p2.bbox_offset\n  let (bw1, bh1) = p1.bbox_size\n  let (bw2, bh2) = p2.bbox_size\n  pos.x = pos.x - (bw2 + box2) + (bw1 + box1)\n  pos.y = pos.y - (bh2 + boy2) + (bh1 + boy1)\n}\n\nfn update_player(player : Object, keys : List[Control]) ->\n     Option[(PlayerSize, Sprite)] {\n  let prev_jumping = player.jumping\n  let prev_dir = player.dir\n  let prev_vx = abs(player.vel.x)\n  map(keys, fn(x) { update_player_keys(player, x) })\n  let v = player.vel.x * friction\n  let vel_damped = if abs(v) < 0.1 {\n    0.0\n  } else {\n    v\n  }\n  player.vel.x = vel_damped\n  let pl_typ = if player.health <= 1 {\n    PlayerSize::Small\n  } else {\n    Large\n  }\n  if prev_jumping.not() && player.jumping {\n    Option::Some(pl_typ, Sprite::make(Player(pl_typ, Jumping), player.dir))\n  } else if prev_dir != player.dir || (prev_vx == 0.0 && abs(player.vel.x) > 0.0) &&\n  player.jumping.not() {\n    Option::Some(pl_typ, Sprite::make(Player(pl_typ, Running), player.dir))\n  } else if prev_dir != player.dir && player.jumping && prev_jumping {\n    Some(pl_typ, Sprite::make(Player(pl_typ, Jumping), player.dir))\n  } else if player.vel.y == 0.0 && player.crouch {\n    Some(pl_typ, Sprite::make(Player(pl_typ, Crouching), player.dir))\n  } else if player.vel.y == 0.0 && player.vel.x == 0.0 {\n    Some(pl_typ, Sprite::make(Player(pl_typ, Standing), player.dir))\n  } else {\n    None\n  }\n}\n\nfn update_vel(self : Object) {\n  if self.grounded {\n    self.vel.y = 0.0\n  } else if self.params.has_gravity {\n    self.vel.y = min(self.vel.y + gravity + abs(self.vel.y) * 0.01, max_y_vel)\n  }\n}\n\nfn update_pos(self : Object) {\n  self.pos.x = self.vel.x + self.pos.x\n  if self.params.has_gravity {\n    self.pos.y = self.vel.y + self.pos.y\n  }\n}\n\nfn process_obj(obj : Object, mapy : Double) {\n  obj.update_vel()\n  obj.update_pos()\n  if obj.pos.y > mapy {\n    obj.kill = true\n  }\n}\n\nfn collide_block(check_x : Bool, dir : Dir2d, obj : Object) {\n  match dir {\n    North => {\n      obj.vel.y = -0.001\n    }\n    South => {\n      obj.vel.y = 0.0\n      obj.grounded = true\n      obj.jumping = false\n    }\n    East | West => if check_x {\n      obj.vel.x = 0.0\n    }\n  }\n}\n\nfn opposite_dir(dir : Dir1d) -> Dir1d {\n  match dir {\n    Left => Right\n    Right => Left\n  }\n}\n\nfn reverse_left_right(obj : Object) {\n  obj.vel.x = -obj.vel.x\n  obj.dir = opposite_dir(obj.dir)\n}\n\nfn evolve_enemy(player_dir : Dir1d, typ : Enemy, spr : Sprite, obj : Object) ->\n     Option[Collidable] {\n  match typ {\n    GKoopa => {\n      let (new_spr, new_obj) = makeobj(\n        new_id(),\n        obj.dir,\n        Enemy(GKoopaShell),\n        obj.pos.x,\n        obj.pos.y,\n      )\n      normalize_pos(new_obj.pos, spr.params, new_spr.params)\n      Some(Enemy(GKoopaShell, new_spr, new_obj))\n    }\n    RKoopa => {\n      let (new_spr, new_obj) = makeobj(\n        new_id(),\n        obj.dir,\n        Enemy(RKoopaShell),\n        obj.pos.x,\n        obj.pos.y,\n      )\n      normalize_pos(new_obj.pos, spr.params, new_spr.params)\n      Some(Enemy(RKoopaShell, new_spr, new_obj))\n    }\n    GKoopaShell | RKoopaShell => {\n      obj.dir = player_dir\n      if obj.vel.x != 0.0 {\n        obj.vel.x = 0.0\n      } else {\n        set_vel_to_speed(obj)\n      }\n      None\n    }\n    _ => {\n      obj.kill = true\n      None\n    }\n  }\n}\n\nfn rev_dir(o : Object, t : Enemy, s : Sprite) {\n  reverse_left_right(o)\n  let old_params = s.params\n  transform_enemy(t, s, o.dir)\n  normalize_pos(o.pos, old_params, s.params)\n}\n\nfn dec_health(obj : Object) {\n  let health = obj.health - 1\n  if health == 0 {\n    obj.kill = true\n  } else if obj.invuln == 0 {\n    obj.health = health\n  }\n}\n\n// (*Used for deleting a block and replacing it with a used block*)\nfn evolve_block(obj : Object) -> Collidable {\n  dec_health(obj)\n  let (new_spr, new_obj) = makeobj(\n    new_id(),\n    Left,\n    Block(QBlockUsed),\n    obj.pos.x,\n    obj.pos.y,\n  )\n  Block(QBlockUsed, new_spr, new_obj)\n}\n\n// (*Used for spawning items above question mark blocks*)\nfn spawn_above(player_dir : Dir1d, obj : Object, typ : Item) -> Collidable {\n  let item = spawn(Item(typ), obj.pos.x, obj.pos.y)\n  let item_obj = get_obj(item)\n  item_obj.pos.y = item_obj.pos.y - get_sprite(item).params.frame_size.1\n  item_obj.dir = opposite_dir(player_dir)\n  set_vel_to_speed(item_obj)\n  item\n}\n\n// (*Used to get the bounding box.*)\nfn get_aabb(obj : Collidable) -> AABB {\n  let spr = get_sprite(obj).params\n  let obj = get_obj(obj)\n  let (offx, offy) = spr.bbox_offset\n  let (box, boy) = (obj.pos.x + offx, obj.pos.y + offy)\n  let (sx, sy) = spr.bbox_size\n  {\n    center: { x: box + sx / 2.0, y: boy + sy / 2.0 },\n    half: { x: sx / 2.0, y: sy / 2.0 },\n  }\n}\n\nfn col_bypass(c1 : Collidable, c2 : Collidable) -> Bool {\n  let o1 = get_obj(c1)\n  let o2 = get_obj(c2)\n  let ctypes = match (c1, c2) {\n    (Item(_, _, _), Enemy(_, _, _)) => true\n    (Enemy(_, _, _), Item(_, _, _)) | (Item(_, _, _), Item(_, _, _)) => true\n    (Player(_, _, o1), Enemy(_, _, _)) => o1.invuln > 0\n    _ => false\n  }\n  o1.kill || o2.kill || ctypes\n}\n\n// (*Used for checking if collisions occur. Compares half-widths and half-heights\n// *and adjusts for when collisions do occur, by changing position so that\n// *a second collision does not occur again immediately. This causes snapping.*)\nfn check_collision(c1 : Collidable, c2 : Collidable) -> Option[Dir2d] {\n  let b1 = get_aabb(c1)\n  let b2 = get_aabb(c2)\n  let o1 = get_obj(c1)\n  if col_bypass(c1, c2) {\n    Option::None\n  } else {\n    let vx = b1.center.x - b2.center.x\n    let vy = b1.center.y - b2.center.y\n    let hwidths = b1.half.x + b2.half.x\n    let hheights = b1.half.y + b2.half.y\n    if abs(vx) < hwidths && abs(vy) < hheights {\n      let ox = hwidths - abs(vx)\n      let oy = hheights - abs(vy)\n      if ox >= oy {\n        if vy > 0.0 {\n          o1.pos.y = o1.pos.y + oy\n          Option::Some(Dir2d::North)\n        } else {\n          o1.pos.y = o1.pos.y - oy\n          Option::Some(Dir2d::South)\n        }\n      } else if vx > 0.0 {\n        o1.pos.x = o1.pos.x + ox\n        Option::Some(Dir2d::West)\n      } else {\n        o1.pos.x = o1.pos.x - ox\n        Option::Some(Dir2d::East)\n      }\n    } else {\n      Option::None\n    }\n  }\n}\n\n// (*\"Kills\" the matched object by setting certain parameters for each.*)\nfn kill(collid : Collidable) -> List[Particle] {\n  match collid {\n    Enemy(t, _, o) => {\n      let pos = { x: o.pos.x, y: o.pos.y }\n      let score = if o.score > 0 {\n        tolist([make_score(o.score, pos)])\n      } else {\n        List::Nil\n      }\n      let remains = match t {\n        Goomba => tolist(\n          [\n            Particle::make(\n              { x: 0.0, y: 0.0 },\n              { x: 0.0, y: 0.0 },\n              GoombaSquish,\n              pos,\n            ),\n          ],\n        )\n        _ => List::Nil\n      }\n      concat(score, remains)\n    }\n    Block(t, _, o) => match t {\n      Brick => {\n        let pos = { x: o.pos.x, y: o.pos.y }\n        let p1 = Particle::make(\n          XY::make(-5.0, -5.0),\n          XY::make(0.0, 0.2),\n          BrickChunkL,\n          XY::make(pos.x, pos.y),\n        )\n        let p2 = Particle::make(\n          XY::make(-3.0, -4.0),\n          XY::make(0.0, 0.2),\n          BrickChunkL,\n          XY::make(pos.x, pos.y),\n        )\n        let p3 = Particle::make(\n          XY::make(3.0, -4.0),\n          XY::make(0.0, 0.2),\n          BrickChunkR,\n          XY::make(pos.x, pos.y),\n        )\n        let p4 = Particle::make(\n          XY::make(5.0, -5.0),\n          XY::make(0.0, 0.2),\n          BrickChunkR,\n          XY::make(pos.x, pos.y),\n        )\n        tolist([p1, p2, p3, p4])\n      }\n      _ => List::Nil\n    }\n    Item(t, _, o) => match t {\n      Mushroom => tolist([make_score(o.score, XY::make(o.pos.x, o.pos.y))])\n      _ => List::Nil\n    }\n    _ => List::Nil\n  }\n}\n","struct ParticleParams {\n  sprite : Sprite\n  lifetime : Int\n}\n\nstruct Particle {\n  params : ParticleParams\n  pos : XY\n  vel : XY\n  acc : XY\n  mut kill : Bool\n  mut life : Int\n}\n\nfn XY::make(x : Double, y : Double) -> XY {\n  { x, y }\n}\n\nfn make_params(sprite_params : SpriteParams, lifetime : Int) -> ParticleParams {\n  { sprite: Sprite::make_(sprite_params), lifetime }\n}\n\nfn ParticleParams::with_type(part : Part) -> ParticleParams {\n  match part {\n    BrickChunkL as t => make_params(make_particle(t), 300)\n    BrickChunkR as t => make_params(make_particle(t), 300)\n    _ as t => make_params(make_particle(t), 30)\n  }\n}\n\nfn Particle::make(vel : XY, acc : XY, part : Part, pos : XY) -> Particle {\n  let params = ParticleParams::with_type(part)\n  { params, pos, vel, acc, kill: false, life: params.lifetime }\n}\n\nfn make_score(score : Int, pos : XY) -> Particle {\n  let t = match score {\n    100 => Part::Score100\n    200 => Score200\n    400 => Score400\n    800 => Score800\n    1000 => Score1000\n    2000 => Score2000\n    4000 => Score4000\n    8000 => Score8000\n    _ => Score100\n  }\n  Particle::make(\n    { x: 0.5, y: -0.7 },\n    { x: 0.0, y: 0.0 },\n    t,\n    { x: pos.x, y: pos.y },\n  )\n}\n\nfn update_vel(self : Particle) {\n  self.vel.x = self.vel.x + self.acc.x\n  self.vel.y = self.vel.y + self.acc.y\n}\n\nfn update_pos(self : Particle) {\n  self.pos.x = self.pos.x + self.vel.x\n  self.pos.y = self.pos.y + self.vel.y\n}\n\nfn process(self : Particle) {\n  self.life = self.life - 1\n  if self.life == 0 {\n    self.kill = true\n  }\n  self.update_vel()\n  self.update_pos()\n}\n","// (* Represents the values of relevant key bindings. *)\nstruct Keys {\n  mut up : Bool\n  mut up2 : Bool\n  mut down : Bool\n  mut down2 : Bool\n  mut left : Bool\n  mut left2 : Bool\n  mut right : Bool\n  mut right2 : Bool\n  mut bbox : Int\n}\n\nstruct St {\n  bgd : Sprite\n  mut vpt : Viewport\n  map : Double\n  mut score : Int\n  mut coins : Int\n  mut multiplier : Int\n  mut game_over : Bool\n}\n\n// (*pressed_keys instantiates the keys.*)\n\nlet pressed_keys : Keys = {\n  up: false,\n  up2: false,\n  down: false,\n  down2: false,\n  left: false,\n  left2: false,\n  right: false,\n  right2: false,\n  bbox: 0,\n}\n\nlet collid_objs : Ref[List[Collidable]] = Ref::make(List::Nil) // (* List of next iteration collidable objects *)\n\nlet particles : Ref[List[Particle]] = Ref::make(List::Nil) // (* List of next iteration particles *)\n\nlet last_time : Ref[Double] = Ref::make(-16.6) // (* Used for calculating fps *)\n\n// (* Calculates fps as the difference between [t0] and [t1] *)\n\nfn calc_fps(t0 : Double, t1 : Double) -> Double {\n  let delta = (t1 - t0) / 1000.0\n  1.0 / delta\n}\n\n// (* Adds [i] to the score in [state] *)\nfn update_score(state : St, i : Int) {\n  state.score = state.score + i\n}\n\nfn player_attack_enemy(o1 : Object, typ : Enemy, s2 : Sprite, o2 : Object,\n        state : St) -> (Option[Collidable], Option[Collidable]) {\n  o1.invuln = 10\n  o1.jumping = false\n  o1.grounded = true\n  match typ {\n    GKoopaShell | RKoopaShell => {\n      let r2 = evolve_enemy(o1.dir, typ, s2, o2)\n      o1.vel.y = -dampen_jump\n      o1.pos.y = o1.pos.y - 5.0\n      (None, r2)\n    }\n    _ => {\n      dec_health(o2)\n      o1.vel.y = -dampen_jump\n      if state.multiplier == 8 {\n        update_score(state, 800)\n        o2.score = 800\n        (None, evolve_enemy(o1.dir, typ, s2, o2))\n      } else {\n        let score = 100 * state.multiplier\n        update_score(state, score)\n        o2.score = score\n        state.multiplier = state.multiplier * 2\n        (None, evolve_enemy(o1.dir, typ, s2, o2))\n      }\n    }\n  }\n}\n\n// (*enemy_attack_player is used when an enemy kills a player.*)\nfn enemy_attack_player(o1 : Object, t2 : Enemy, s2 : Sprite, o2 : Object) ->\n     (Option[Collidable], Option[Collidable]) {\n  match t2 {\n    GKoopaShell | RKoopaShell => {\n      let r2 = if o2.vel.x == 0.0 {\n        evolve_enemy(o1.dir, t2, s2, o2)\n      } else {\n        dec_health(o1)\n        o1.invuln = invuln\n        None\n      }\n      (None, r2)\n    }\n    _ => {\n      dec_health(o1)\n      o1.invuln = invuln\n      (None, None)\n    }\n  }\n}\n\n// (*In the case that two enemies collide, they are to reverse directions. However,\n// *in the case that one or more of the two enemies is a koopa shell, then\n// *the koopa shell kills the other enemy. *)\nfn col_enemy_enemy(t1 : Enemy, s1 : Sprite, o1 : Object, t2 : Enemy, s2 : Sprite,\n        o2 : Object, dir : Dir2d) -> (Option[Collidable], Option[Collidable]) {\n  match (t1, t2) {\n    (GKoopaShell, GKoopaShell) | (GKoopaShell, RKoopaShell) => {\n      dec_health(o1)\n      dec_health(o2)\n      (None, None)\n    }\n    (RKoopaShell, RKoopaShell) | (RKoopaShell, GKoopaShell) => {\n      dec_health(o1)\n      dec_health(o2)\n      (None, None)\n    }\n    (RKoopaShell, _) | (GKoopaShell, _) => if o1.vel.x == 0.0 {\n      rev_dir(o2, t2, s2)\n      (None, None)\n    } else {\n      dec_health(o2)\n      (None, None)\n    }\n    (_, RKoopaShell) | (_, GKoopaShell) => if o2.vel.x == 0.0 {\n      rev_dir(o1, t1, s1)\n      (None, None)\n    } else {\n      dec_health(o1)\n      (None, None)\n    }\n    _ => match dir {\n      West | East => {\n        rev_dir(o1, t1, s1)\n        rev_dir(o2, t2, s2)\n        (None, None)\n      }\n      _ => (None, None)\n    }\n  }\n}\n\n// (* Run the broad phase object filtering *)\nfn broad_phase(collid : Collidable, all_collids : List[Collidable], state : St) ->\n     List[Collidable] {\n  let obj = get_obj(collid)\n  filter(\n    all_collids,\n    fn(c) {\n      in_viewport(state.vpt, obj.pos) || is_player(collid) || out_of_viewport_below(\n        state.vpt,\n        obj.pos.y,\n      )\n    },\n  )\n}\n\n// (*narrow_phase of collision is used in order to continuously loop through\n// *each of the collidable objects to constantly check if collisions are\n// *occurring.*)\nfn narrow_phase(c : Collidable, cs : List[Collidable], state : St) ->\n     List[Collidable] {\n  fn narrow_helper(c : Collidable, cs : List[Collidable], state : St,\n          acc : List[Collidable]) -> List[Collidable] {\n    match cs {\n      Nil => acc\n      Cons(h, t) => {\n        let c_obj = get_obj(c)\n        let new_objs = if c != h {\n          match check_collision(c, h) {\n            None => (Option::None, Option::None)\n            Some(dir) => if get_obj(h).id != c_obj.id {\n              process_collision(dir, c, h, state)\n            } else {\n              (None, None)\n            }\n          }\n        } else {\n          (None, None)\n        }\n        let acc = match new_objs {\n          (None, Some(o)) => List::Cons(o, acc)\n          (Some(o), None) => List::Cons(o, acc)\n          (Some(o1), Some(o2)) => Cons(o1, Cons(o2, acc))\n          (None, None) => acc\n        }\n        narrow_helper(c, t, state, acc)\n      }\n    }\n  }\n\n  narrow_helper(c, cs, state, Nil)\n}\n\n// (* This is an optimization setp to determine which objects require narrow phase\n// * checking. This excludes static collidables, allowing collision to only be\n// * checked with moving objects. This method is called once per collidable.\n// * Collision detection proceeds as follows:\n// * 1. Broad phase - filter collidables that cannot possibly collide with\n// *    this object.\n// * 2. Narrow phase - compare against all objects to determine whether there\n// *    is a collision, and process the collision.\n// * This method returns a list of objects that are created, which should be\n// * added to the list of collidables for the next iteration.\n// * *)\nfn check_collisions(collid : Collidable, all_collids : List[Collidable],\n        state : St) -> List[Collidable] {\n  match collid {\n    Block(_, _, _) => Nil\n    _ => {\n      let broad = broad_phase(collid, all_collids, state)\n      narrow_phase(collid, broad, state)\n    }\n  }\n}\n\n// (* Returns whether the bounding box should be drawn *)\nfn check_bbox_enabled() -> Bool {\n  pressed_keys.bbox == 1\n}\n\n// (* update_collidable is the primary update method for collidable objects,\n// * checking the collision, updating the object, and drawing to the canvas.*)\nfn update_collidable(state : St, collid : Collidable,\n        all_collids : List[Collidable]) -> List[Collidable] {\n  let obj = get_obj(collid)\n  let spr = get_sprite(collid)\n  obj.invuln = if obj.invuln > 0 {\n    obj.invuln - 1\n  } else {\n    0\n  }\n  // (* Prevent position from being updated outside of viewport *)\n  let viewport_filter = in_viewport(state.vpt, obj.pos) || is_player(collid) || out_of_viewport_below(\n      state.vpt,\n      obj.pos.y,\n    )\n  if not(obj.kill) && viewport_filter {\n    obj.grounded = false\n    process_obj(obj, state.map)\n    // (* Run collision detection if moving object*)\n    let evolved = check_collisions(collid, all_collids, state)\n    // (* Render and update animation *)\n    let vpt_adj_xy = coord_to_viewport(state.vpt, obj.pos)\n    render(spr, vpt_adj_xy.x, vpt_adj_xy.y)\n    if check_bbox_enabled() {\n      render_box(spr, vpt_adj_xy.x, vpt_adj_xy.y)\n    }\n    if obj.vel.x != 0.0 || not(is_enemy(collid)) {\n      update_animation(spr)\n    }\n    evolved\n  } else {\n    Nil\n  }\n}\n\n// (* Converts a keypress to a list of control keys, allowing more than one key\n// * to be processed each frame. *)\nfn translate_keys() -> List[Control] {\n  let mut res = List::Nil\n  if which.value {\n    if pressed_keys.up {\n      res = List::Cons(Control::Up, res)\n    }\n    if pressed_keys.down {\n      res = List::Cons(Control::Down, res)\n    }\n    if pressed_keys.left {\n      res = List::Cons(Control::Left, res)\n    }\n    if pressed_keys.right {\n      res = List::Cons(Control::Right, res)\n    }\n  } else {\n    if pressed_keys.up2 {\n      res = List::Cons(Control::Up, res)\n    }\n    if pressed_keys.down2 {\n      res = List::Cons(Control::Down, res)\n    }\n    if pressed_keys.left2 {\n      res = List::Cons(Control::Left, res)\n    }\n    if pressed_keys.right2 {\n      res = List::Cons(Control::Right, res)\n    }\n  }\n  res\n}\n\n// (* run_update is used to update all of the collidables at once. Primarily used\n// * as a wrapper method. This method is necessary to differentiate between\n// * the player collidable and the remaining collidables, as special operations\n// * such as viewport centering only occur with the player.*)\nfn run_update_collid(state : St, collid : Collidable,\n        all_collids : List[Collidable]) -> Collidable {\n  match collid {\n    Player(_, s, o) as p => {\n      let keys = translate_keys()\n      o.crouch = false\n      let player = match update_player(o, keys) {\n        None => p\n        Some(new_typ, new_spr) => {\n          normalize_pos(o.pos, s.params, new_spr.params)\n          Player(new_typ, new_spr, o)\n        }\n      }\n      let evolved = update_collidable(state, player, all_collids)\n      collid_objs.value = concat(collid_objs.value, evolved)\n      player\n    }\n    _ => {\n      let obj = get_obj(collid)\n      let evolved = update_collidable(state, collid, all_collids)\n      if not(obj.kill) {\n        collid_objs.value = List::Cons(\n          collid,\n          concat(collid_objs.value, evolved),\n        )\n      }\n      let new_parts = if obj.kill {\n        kill(collid)\n      } else {\n        List::Nil\n      }\n      particles.value = concat(particles.value, new_parts)\n      collid\n    }\n  }\n}\n\n// (* Primary update function to update and persist a particle *)\nfn run_update_particle(state : St, part : Particle) {\n  process(part)\n  let x = part.pos.x - state.vpt.pos.x\n  let y = part.pos.y - state.vpt.pos.y\n  render(part.params.sprite, x, y)\n  if not(part.kill) {\n    particles.value = List::Cons(part, particles.value)\n  }\n}\n\nlet which : Ref[Bool] = Ref::make(true)\n\nfn update_helper(time : Double, state : St, objs : List[Collidable],\n        parts : List[Particle]) {\n  if state.game_over == true {\n    match first(players.value, fn(p) { get_obj(p).kill.not() }) {\n      None => game_lose()\n      Some(_) => game_win()\n    }\n  } else {\n    collid_objs.value = List::Nil\n    particles.value = List::Nil\n    let fps_ = calc_fps(last_time.value, time).to_int()\n    last_time.value = time\n    clear_canvas()\n\n    // (* Parallax background *)\n    let vpos_x_int = (state.vpt.pos.x / 5.0).to_int()\n    let bgd_width = state.bgd.params.frame_size.0.to_int()\n    draw_bgd(state.bgd, (vpos_x_int % bgd_width).to_double())\n    which.value = false\n    players.value = map(\n      players.value,\n      fn(p) {\n        which.value = not(which.value)\n        run_update_collid(state, p, objs)\n      },\n    )\n    match first(players.value, fn(p) { get_obj(p).kill.not() }) {\n      None => {\n        state.game_over = true\n        game_lose()\n      }\n      Some(p) => {\n        let a = get_obj(p).pos\n        let Some(p) = last(players.value, fn(p) { get_obj(p).kill.not() })\n        let b = get_obj(p).pos\n        let c = XY::make((a.x + b.x) * 0.5, (a.y + b.y) * 0.5)\n        state.vpt = update(state.vpt, c)\n        let _ = map(objs, fn(obj) { run_update_collid(state, obj, objs) })\n        let _ = map(parts, fn(part) { run_update_particle(state, part) })\n        fps(fps_)\n        hud(state.score, state.coins)\n      }\n    }\n  }\n}\n\npub fn game_update(t : Double) {\n  update_helper(t, state, collid_objs.value, particles.value)\n}\n\npub fn keydown_B() {\n  pressed_keys.bbox = pressed_keys.bbox.lxor(1)\n}\n\npub fn keydown_up() {\n  pressed_keys.up = true\n}\n\npub fn keydown_up2() {\n  pressed_keys.up2 = true\n}\n\npub fn keydown_down() {\n  pressed_keys.down = true\n}\n\npub fn keydown_down2() {\n  pressed_keys.down2 = true\n}\n\npub fn keydown_left() {\n  pressed_keys.left = true\n}\n\npub fn keydown_left2() {\n  pressed_keys.left2 = true\n}\n\npub fn keydown_right() {\n  pressed_keys.right = true\n}\n\npub fn keydown_right2() {\n  pressed_keys.right2 = true\n}\n\npub fn keyup_up() {\n  pressed_keys.up = false\n}\n\npub fn keyup_up2() {\n  pressed_keys.up2 = false\n}\n\npub fn keyup_down() {\n  pressed_keys.down = false\n}\n\npub fn keyup_down2() {\n  pressed_keys.down2 = false\n}\n\npub fn keyup_left() {\n  pressed_keys.left = false\n}\n\npub fn keyup_left2() {\n  pressed_keys.left2 = false\n}\n\npub fn keyup_right() {\n  pressed_keys.right = false\n}\n\npub fn keyup_right2() {\n  pressed_keys.right2 = false\n}\n","// (* Process collision is called to match each of the possible collisions that\n// * may occur. Returns a pair of collidable options, representing objects that\n// * were created from the existing ones. That is, the first element represents\n// * a new item spawned as a result of the first collidable. None indicates that\n// * no new item should be spawned. Transformations to existing objects occur\n// * mutably, as many changes are side-effectual.*)\nfn process_collision(dir : Dir2d, c1 : Collidable, c2 : Collidable, state : St) ->\n     (Option[Collidable], Option[Collidable]) {\n  match (c1, c2, dir) {\n    (Player(_, _, o1), Enemy(typ, s2, o2), South)\n    |\n    (Enemy(typ, s2, o2), Player(_, _, o1), North) => player_attack_enemy(\n      o1,\n      typ,\n      s2,\n      o2,\n      state,\n    )\n    (Player(_, _, o1), Enemy(t2, s2, o2), _)\n    |\n    (Enemy(t2, s2, o2), Player(_, _, o1), _) => enemy_attack_player(\n      o1,\n      t2,\n      s2,\n      o2,\n    )\n    (Player(_, _, o1), Item(t2, _, o2), _)\n    |\n    (Item(t2, _, o2), Player(_, _, o1), _) => match t2 {\n      Mushroom => {\n        dec_health(o2)\n        if o1.health == 2 {\n          ()\n        } else {\n          o1.health = o1.health + 1\n        }\n        o1.vel.x = 0.0\n        o1.vel.y = 0.0\n        update_score(state, 1000)\n        o2.score = 1000\n        (None, None)\n      }\n      Coin => {\n        state.coins = state.coins + 1\n        dec_health(o2)\n        update_score(state, 100)\n        (None, None)\n      }\n    }\n    (Enemy(t1, s1, o1), Enemy(t2, s2, o2), dir) => col_enemy_enemy(\n      t1,\n      s1,\n      o1,\n      t2,\n      s2,\n      o2,\n      dir,\n    )\n    (Enemy(t1, s1, o1), Block(t2, _, o2), East)\n    |\n    (Enemy(t1, s1, o1), Block(t2, _, o2), West) => match (t1, t2) {\n      (RKoopaShell, Brick) | (GKoopaShell, Brick) => {\n        dec_health(o2)\n        reverse_left_right(o1)\n        (None, None)\n      }\n      (RKoopaShell, QBlock(typ)) | (GKoopaShell, QBlock(typ)) => {\n        let updated_block = evolve_block(o2)\n        let spawned_item = spawn_above(o1.dir, o2, typ)\n        rev_dir(o1, t1, s1)\n        (Some(updated_block), Some(spawned_item))\n      }\n      (_, _) => {\n        rev_dir(o1, t1, s1)\n        (None, None)\n      }\n    }\n    (Item(_, _, o1), Block(_), East) | (Item(_, _, o1), Block(_), West) => {\n      reverse_left_right(o1)\n      (None, None)\n    }\n    (Enemy(_, _, o1), Block(_), _) | (Item(_, _, o1), Block(_), _) => {\n      collide_block(true, dir, o1)\n      (None, None)\n    }\n    (Player(t1, _, o1), Block(t, _, o2), North) => match t {\n      QBlock(typ) => {\n        let updated_block = evolve_block(o2)\n        let spawned_item = spawn_above(o1.dir, o2, typ)\n        collide_block(true, dir, o1)\n        (Option::Some(spawned_item), Option::Some(updated_block))\n      }\n      Brick => if t1 == Large {\n        collide_block(true, dir, o1)\n        dec_health(o2)\n        (None, None)\n      } else {\n        collide_block(true, dir, o1)\n        (None, None)\n      }\n      Panel => {\n        state.game_over = true\n        game_win()\n        (None, None)\n      }\n      _ => {\n        collide_block(true, dir, o1)\n        (None, None)\n      }\n    }\n    (Player(_, _, o1), Block(t, _, _), _) => match t {\n      Panel => {\n        state.game_over = true\n        game_win()\n        (None, None)\n      }\n      _ => match dir {\n        South => {\n          state.multiplier = 1\n          collide_block(true, dir, o1)\n          (None, None)\n        }\n        _ => {\n          collide_block(true, dir, o1)\n          (None, None)\n        }\n      }\n    }\n    _ => (None, None)\n  }\n}\n","struct Viewport {\n  pos : XY\n  v_dim : XY\n  m_dim : XY\n}\n\nfn Viewport::make(v : XY, m : XY) -> Viewport {\n  {\n    pos: { x: 0.0, y: 0.0 },\n    v_dim: { x: v.x, y: v.y },\n    m_dim: { x: m.x, y: m.y },\n  }\n}\n\nfn calc_viewport_point(cc : Double, vc : Double, mc : Double) -> Double {\n  let vc_half = vc / 2.0\n  min(max(cc - vc_half, 0.0), min(mc - vc, abs(cc - vc_half)))\n}\n\n// (* Returns whether a coordinate pair [pos] is inside the viewport [v] *)\nfn in_viewport(v : Viewport, pos : XY) -> Bool {\n  let margin = 32.0\n  let (v_min_x, v_max_x) = (v.pos.x - margin, v.pos.x + v.v_dim.x)\n  let (v_min_y, v_max_y) = (v.pos.y - margin, v.pos.y + v.v_dim.y)\n  let (x, y) = (pos.x, pos.y)\n  x >= v_min_x && x <= v_max_x && y >= v_min_y && y <= v_max_y\n}\n\n// (* Returns whether an object is outside of the viewport and below it. This is\n// * useful for determining whether to process falling out of screen normally. *)\nfn out_of_viewport_below(v : Viewport, y : Double) -> Bool {\n  let v_max_y = v.pos.y + v.v_dim.y\n  y >= v_max_y\n}\n\n// (* Converts a x,y [coord] pair in absolute coordinates to coordinates relative\n// * to the viewport *)\nfn coord_to_viewport(viewport : Viewport, coord : XY) -> XY {\n  { x: coord.x - viewport.pos.x, y: coord.y - viewport.pos.y }\n}\n\n// (* Update the viewport [vpt] given the new center x,y coordinate pair [ctr] *)\nfn update(vpt : Viewport, ctr : XY) -> Viewport {\n  let new_x = calc_viewport_point(ctr.x, vpt.v_dim.x, vpt.m_dim.x)\n  let new_y = calc_viewport_point(ctr.y, vpt.v_dim.y, vpt.m_dim.y)\n  let pos = { x: new_x, y: new_y }\n  { pos, v_dim: vpt.v_dim, m_dim: vpt.m_dim }\n}\n","// (*Note: Canvas is 512 by 256 (w*h) -> 32 by 16 blocks*)\n\n// (*Holds obj typ and its coordinates. (int, (x-coord, y-coord))*)\n// type obj_coord =  int * (float * float)\n\n// (*Checks if the given location checkloc is already part of the list of locations\n// * in loclist.*)\nfn mem_loc(checkloc : (Double, Double), loclist : List[(Int, (Double, Double))]) ->\n     Bool {\n  match loclist {\n    Nil => false\n    Cons(h, t) => checkloc.0 == h.1.0 && checkloc.1 == h.1.1 || mem_loc(\n      checkloc,\n      t,\n    )\n  }\n}\n\n// (*Converts list of locations from blocksize to pixelsize by multiplying (x,y) by\n// * 16.*)\nfn convert_list(list : List[(Int, (Double, Double))]) ->\n     List[(Int, (Double, Double))] {\n  map(list, fn(x) { (x.0, (x.1.0 * 16.0, x.1.1 * 16.0)) })\n}\n\n// (*Chooses what type of enemy should be instantiated given typ number*)\nfn choose_enemy_typ(typ : Int) -> Enemy {\n  match typ {\n    0 => RKoopa\n    1 => GKoopa\n    2 => Goomba\n    _ => abort(\"Shouldn't reach here\")\n  }\n}\n\n// (*Chooses what type of block should be instantiated given typ number*)\nfn choose_sblock_typ(typ : Int) -> Block {\n  match typ {\n    0 => Brick\n    1 => UnBBlock\n    2 => Cloud\n    3 => QBlock(Mushroom)\n    4 => Ground\n    _ => abort(\"Shouldn't reach here\")\n  }\n}\n\n// (*Optimizes lst such that there are no two items in the list that have the same\n// * coordinates. If there is one, it is removed.*)\nfn avoid_overlap(lst : List[(Int, (Double, Double))],\n        currentLst : List[(Int, (Double, Double))]) ->\n     List[(Int, (Double, Double))] {\n  match lst {\n    Nil => Nil\n    Cons(h, t) => if mem_loc(h.1, currentLst) {\n      avoid_overlap(t, currentLst)\n    } else {\n      Cons(h, avoid_overlap(t, currentLst))\n    }\n  }\n}\n\n// (*Gets rid of objects with coordinates in the ending frame, within 128 pixels of\n// * the start, at the very top, and two blocks from the ground.*)\nfn trim_edges(lst : List[(Int, (Double, Double))], blockw : Double,\n        blockh : Double) -> List[(Int, (Double, Double))] {\n  match lst {\n    Nil => Nil\n    Cons(h, t) => {\n      let cx = h.1.0\n      let cy = h.1.1\n      let pixx = blockw * 16.0\n      let pixy = blockh * 16.0\n      if cx < 128.0 || pixx - cx < 528.0 || cy == 0.0 || pixy - cy < 48.0 {\n        trim_edges(t, blockw, blockh)\n      } else {\n        Cons(h, trim_edges(t, blockw, blockh))\n      }\n    }\n  }\n}\n\n// (*Generates a stair formation with block typ being dependent on typ. This type\n// * of stair formation requires that the first step be on the ground.*)\nfn generate_ground_stairs(cbx : Double, cby : Double, typ : Int) ->\n     List[(Int, (Double, Double))] {\n  let x = List::Nil\n  let x = List::Cons((typ, (cbx + 3.0, cby - 3.0)), x)\n  let x = List::Cons((typ, (cbx + 3.0, cby - 2.0)), x)\n  let x = List::Cons((typ, (cbx + 2.0, cby - 2.0)), x)\n  let x = List::Cons((typ, (cbx + 3.0, cby - 1.0)), x)\n  let x = List::Cons((typ, (cbx + 2.0, cby - 1.0)), x)\n  let x = List::Cons((typ, (cbx + 1.0, cby - 1.0)), x)\n  let x = List::Cons((typ, (cbx + 3.0, cby - 0.0)), x)\n  let x = List::Cons((typ, (cbx + 2.0, cby - 0.0)), x)\n  let x = List::Cons((typ, (cbx + 1.0, cby - 0.0)), x)\n  let x = List::Cons((typ, (cbx + 0.0, cby - 0.0)), x)\n  x\n}\n\n// (*Generates a stair formation going upwards.*)\nfn generate_airup_stairs(cbx : Double, cby : Double, typ : Int) ->\n     List[(Int, (Double, Double))] {\n  let x = List::Nil\n  let x = List::Cons((typ, (cbx + 6.0, cby - 2.0)), x)\n  let x = List::Cons((typ, (cbx + 5.0, cby - 2.0)), x)\n  let x = List::Cons((typ, (cbx + 4.0, cby - 2.0)), x)\n  let x = List::Cons((typ, (cbx + 4.0, cby - 1.0)), x)\n  let x = List::Cons((typ, (cbx + 3.0, cby - 1.0)), x)\n  let x = List::Cons((typ, (cbx + 1.0, cby - 0.0)), x)\n  let x = List::Cons((typ, (cbx + 0.0, cby - 0.0)), x)\n  x\n}\n\n// (*Generates a stair formation going downwards*)\nfn generate_airdown_stairs(cbx : Double, cby : Double, typ : Int) ->\n     List[(Int, (Double, Double))] {\n  let x = List::Nil\n  let x = List::Cons((typ, (cbx + 6.0, cby + 2.0)), x)\n  let x = List::Cons((typ, (cbx + 5.0, cby + 2.0)), x)\n  let x = List::Cons((typ, (cbx + 3.0, cby + 1.0)), x)\n  let x = List::Cons((typ, (cbx + 2.0, cby + 1.0)), x)\n  let x = List::Cons((typ, (cbx + 2.0, cby + 0.0)), x)\n  let x = List::Cons((typ, (cbx + 1.0, cby + 0.0)), x)\n  let x = List::Cons((typ, (cbx + 0.0, cby + 0.0)), x)\n  x\n}\n\n// (*Generates a cloud block platform with some length num.*)\nfn generate_clouds(cbx : Double, cby : Double, typ : Int, num : Int) ->\n     List[(Int, (Double, Double))] {\n  if num <= 0 {\n    List::Nil\n  } else {\n    List::Cons((typ, (cbx, cby)), generate_clouds(cbx + 1.0, cby, typ, num - 1))\n  }\n}\n\nfn generate_coins(block_coord : List[(Int, (Double, Double))]) ->\n     List[(Int, (Double, Double))] {\n  // (* let place_coin = Random.int 2 in *)\n  let place_coin = random(0, 2)\n  match block_coord {\n    List::Nil => List::Nil\n    List::Cons(h, t) => if place_coin == 0 {\n      let xc = h.1.0\n      let yc = h.1.1\n      List::Cons((0, (xc, yc - 16.0)), generate_coins(t))\n    } else {\n      generate_coins(t)\n    }\n  }\n}\n\n// (*Chooses the form of the blocks to be placed.\n// * When called, leaves a 1 block gap from canvas size.\n// * 1. If current xblock or yblock is greater than canvas width or height\n// *    respectively, return an empty list.\n// * 2. If current xblock or yblock is within 10 blocks of the left and right sides\n// *    of the level map, prevent any objects from being initialized.\n// * 3. Else call helper methods to created block formations and return obj_coord\n// *    list.\n// **)\nfn choose_block_pattern(blockw : Double, blockh : Double, cbx : Double,\n        cby : Double, prob : Int) -> List[(Int, (Double, Double))] {\n  if cbx > blockw || cby > blockh {\n    List::Nil\n  } else {\n    let block_typ = random(0, 4)\n    let stair_typ = random(0, 2)\n    let life_block_chance = random(0, 5)\n    let middle_block = if life_block_chance == 0 {\n      3\n    } else {\n      stair_typ\n    }\n    match prob {\n      0 => if blockw - cbx > 2.0 {\n        tolist(\n          [\n            (stair_typ, (cbx, cby)),\n            (middle_block, (cbx + 1.0, cby)),\n            (stair_typ, (cbx + 2.0, cby)),\n          ],\n        )\n      } else if blockw - cbx > 1.0 {\n        tolist([(block_typ, (cbx, cby)), (block_typ, (cbx + 1.0, cby))])\n      } else {\n        tolist([(block_typ, (cbx, cby))])\n      }\n      1 => {\n        let num_clouds = random(0, 5) + 5\n        if cby < 5.0 {\n          generate_clouds(cbx, cby, 2, num_clouds)\n        } else {\n          List::Nil\n        }\n      }\n      2 => if blockh - cby == 1.0 {\n        generate_ground_stairs(cbx, cby, stair_typ)\n      } else {\n        List::Nil\n      }\n      3 => if stair_typ == 0 && blockh - cby > 3.0 {\n        generate_airdown_stairs(cbx, cby, stair_typ)\n      } else if blockh - cby > 2.0 {\n        generate_airup_stairs(cbx, cby, stair_typ)\n      } else {\n        tolist([(stair_typ, (cbx, cby))])\n      }\n      4 => if cby + 3.0 - blockh == 2.0 {\n        tolist([(stair_typ, (cbx, cby))])\n      } else if cby + 3.0 - blockh == 1.0 {\n        tolist([(stair_typ, (cbx, cby)), (stair_typ, (cbx, cby + 1.0))])\n      } else {\n        tolist(\n          [\n            (stair_typ, (cbx, cby)),\n            (stair_typ, (cbx, cby + 1.0)),\n            (stair_typ, (cbx, cby + 2.0)),\n          ],\n        )\n      }\n      5 => tolist([(3, (cbx, cby))])\n      _ => abort(\"\")\n    }\n  }\n}\n\n// (*Generates a list of enemies to be placed on the ground.*)\nfn generate_enemies(blockw : Double, blockh : Double, cbx : Double, cby : Double,\n        acc : List[(Int, (Double, Double))]) -> List[(Int, (Double, Double))] {\n  if cbx > blockw - 32.0 {\n    List::Nil\n  } else if cby > blockh - 1.0 || cbx < 15.0 {\n    generate_enemies(blockw, blockh, cbx + 1.0, 0.0, acc)\n  } else if mem_loc((cbx, cby), acc) || cby == 0.0 {\n    generate_enemies(blockw, blockh, cbx, cby + 1.0, acc)\n  } else {\n    let prob = random(0, 30)\n    let enem_prob = 3\n    if prob < enem_prob && blockh - 1.0 == cby {\n      List::Cons(\n        (prob, (cbx * 16.0, cby * 16.0)),\n        generate_enemies(blockw, blockh, cbx, cby + 1.0, acc),\n      )\n    } else {\n      generate_enemies(blockw, blockh, cbx, cby + 1.0, acc)\n    }\n  }\n}\n\n// (*Generates a list of enemies to be placed upon the block objects.*)\nfn generate_block_enemies(block_coord : List[(Int, (Double, Double))]) ->\n     List[(Int, (Double, Double))] {\n  let place_enemy = random(0, 20)\n  let enemy_typ = random(0, 3)\n  match block_coord {\n    Nil => Nil\n    Cons(h, t) => if place_enemy == 0 {\n      let xc = h.1.0\n      let yc = h.1.1\n      List::Cons((enemy_typ, (xc, yc - 16.0)), generate_block_enemies(t))\n    } else {\n      generate_block_enemies(t)\n    }\n  }\n}\n\n// (*Generates an obj_coord list (typ, coordinates) of blocks to be placed.*)\nfn generate_block_locs(blockw : Double, blockh : Double, cbx : Double,\n        cby : Double, acc : List[(Int, (Double, Double))]) ->\n     List[(Int, (Double, Double))] {\n  if blockw - cbx < 33.0 {\n    acc\n  } else if cby > blockh - 1.0 {\n    generate_block_locs(blockw, blockh, cbx + 1.0, 0.0, acc)\n  } else if mem_loc((cbx, cby), acc) || cby == 0.0 {\n    generate_block_locs(blockw, blockh, cbx, cby + 1.0, acc)\n  } else {\n    let prob = random(0, 100)\n    let block_prob = 5\n    if prob < block_prob {\n      let newacc = choose_block_pattern(blockw, blockh, cbx, cby, prob)\n      let undup_lst = avoid_overlap(newacc, acc)\n      let called_acc = concat(acc, undup_lst)\n      generate_block_locs(blockw, blockh, cbx, cby + 1.0, called_acc)\n    } else {\n      generate_block_locs(blockw, blockh, cbx, cby + 1.0, acc)\n    }\n  }\n}\n\n// (*Generates the ending item panel at the end of the level. Games ends upon\n// * collision with player.*)\nfn generate_panel(blockw : Double, blockh : Double) -> Collidable {\n  spawn(Block(Panel), blockw * 16.0 - 256.0, blockh * 16.0 * 2.0 / 3.0)\n}\n\n// (*Generates the list of brick locations needed to display the ground.\n// * 1/10 chance that a ground block is skipped each call to create holes.*)\nfn generate_ground(blockw : Double, blockh : Double, inc : Double,\n        acc : List[(Int, (Double, Double))]) -> List[(Int, (Double, Double))] {\n  if inc > blockw {\n    acc\n  } else if inc > 10.0 {\n    let skip = random(0, 10)\n    let newacc = concat(acc, tolist([(4, (inc * 16.0, blockh * 16.0))]))\n    if skip == 7 && blockw - inc > 32.0 {\n      generate_ground(blockw, blockh, inc + 1.0, acc)\n    } else {\n      generate_ground(blockw, blockh, inc + 1.0, newacc)\n    }\n  } else {\n    let newacc = concat(acc, tolist([(4, (inc * 16.0, blockh * 16.0))]))\n    generate_ground(blockw, blockh, inc + 1.0, newacc)\n  }\n}\n\n// (*Converts the obj_coord list called by generate_block_locs to a list of objects\n// * with the coordinates given from the obj_coord list. *)\nfn convert_to_block_obj(lst : List[(Int, (Double, Double))]) -> List[Collidable] {\n  match lst {\n    Nil => Nil\n    Cons(h, t) => {\n      let sblock_typ = choose_sblock_typ(h.0)\n      let ob = spawn(Block(sblock_typ), h.1.0, h.1.1)\n      concat(tolist([ob]), convert_to_block_obj(t))\n    }\n  }\n}\n\n// (*Converts the obj_coord list called by generate_enemies to a list of objects\n// * with the coordinates given from the obj_coord list. *)\nfn convert_to_enemy_obj(lst : List[(Int, (Double, Double))]) -> List[Collidable] {\n  match lst {\n    Nil => Nil\n    Cons(h, t) => {\n      let senemy_typ = choose_enemy_typ(h.0)\n      let ob = spawn(Enemy(senemy_typ), h.1.0, h.1.1)\n      concat(tolist([ob]), convert_to_enemy_obj(t))\n    }\n  }\n}\n\n// (*Converts the list of coordinates into a list of Coin objects*)\nfn convert_to_coin_obj(lst : List[(Int, (Double, Double))]) -> List[Collidable] {\n  match lst {\n    Nil => Nil\n    Cons(h, t) => {\n      let sitem_typ = Item::Coin\n      let ob = spawn(Item(sitem_typ), h.1.0, h.1.1)\n      concat(tolist([ob]), convert_to_coin_obj(t))\n    }\n  }\n}\n\n// (*Procedurally generates a list of collidables given canvas width, height and\n// * context. Arguments block width (blockw) and block height (blockh) are in\n// * block form, not pixels.*)\nfn generate_helper(blockw : Double, blockh : Double) -> List[Collidable] {\n  let block_locs = generate_block_locs(blockw, blockh, 0.0, 0.0, Nil)\n  let converted_block_locs = trim_edges(\n    convert_list(block_locs),\n    blockw,\n    blockh,\n  )\n  let obj_converted_block_locs = convert_to_block_obj(converted_block_locs)\n  let ground_blocks = generate_ground(blockw, blockh, 0.0, Nil)\n  let obj_converted_ground_blocks = convert_to_block_obj(ground_blocks)\n  let block_locations = concat(block_locs, ground_blocks)\n  let all_blocks = concat(obj_converted_block_locs, obj_converted_ground_blocks)\n  let enemy_locs = generate_enemies(blockw, blockh, 0.0, 0.0, block_locations)\n  let obj_converted_enemies = convert_to_enemy_obj(enemy_locs)\n  let coin_locs = generate_coins(converted_block_locs)\n  let undup_coin_locs = trim_edges(\n    avoid_overlap(coin_locs, converted_block_locs),\n    blockw,\n    blockh,\n  )\n  let converted_block_coin_locs = concat(converted_block_locs, coin_locs)\n  let enemy_block_locs = generate_block_enemies(converted_block_locs)\n  let undup_enemy_block_locs = avoid_overlap(\n    enemy_block_locs,\n    converted_block_coin_locs,\n  )\n  let obj_enemy_blocks = convert_to_enemy_obj(undup_enemy_block_locs)\n  let coin_objects = convert_to_coin_obj(undup_coin_locs)\n  let obj_panel = generate_panel(blockw, blockh)\n  concat(\n    all_blocks,\n    concat(\n      obj_converted_enemies,\n      concat(coin_objects, concat(obj_enemy_blocks, tolist([obj_panel]))),\n    ),\n  )\n}\n\n// (*Main function called to procedurally generate the level map. w and h args\n// * are in pixel form. Converts to block form to call generate_helper. Spawns\n// * the list of collidables received from generate_helper to display on canvas.*)\npub fn generate(player_count : Int, w : Double, h : Double) ->\n     (List[Collidable], List[Collidable]) {\n  let blockw = w / 16.0\n  let blockh = h / 16.0 - 1.0\n  let collide_list = generate_helper(blockw, blockh)\n  let mut start = 50.0\n  let players = map(\n    tolist(Array::make(player_count, Spawn::Player(Small, Standing))),\n    fn(s) {\n      let c = spawn(s, start, 0.0)\n      start = start - 30.0\n      c\n    },\n  )\n  (players, collide_list)\n}\n","let level_width : Double = 2400.0\n\nlet level_height : Double = 256.0\n\nlet player_count = 2\n\nlet temp : (List[Collidable], List[Collidable]) = generate(\n  player_count,\n  level_width,\n  level_height,\n)\n\nlet players : Ref[List[Collidable]] = Ref::make(temp.0)\n\nlet objs : List[Collidable] = temp.1\n\nlet map_dim : XY = { x: 2400.0, y: 256.0 }\n\nlet cwidth = 512.0\n\nlet cheight = 256.0\n\nlet viewport : Viewport = Viewport::make({ x: cwidth, y: cheight }, map_dim)\n\nlet state : St = {\n  bgd: make_bgd(),\n  vpt: update(viewport, get_obj(at(players.value, 0)).pos),\n  map: map_dim.y,\n  score: 0,\n  coins: 0,\n  multiplier: 1,\n  game_over: false,\n}\n\nfn init {\n  update_helper(0.0, state, objs, List::Nil)\n}\n"],"mappings":"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"}